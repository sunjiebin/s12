
cmdb系统的设计

设计思路
    重点归纳:
        在数据表的一对一/多对多等的关联中,是A关联B,还是B关联A这个是有顺序的.不同的关联会实现不同的效果.
    1.用什么作为资产id?
        最好就用自增的数字来作为id，资产id不需要可识别，不需要有特殊意义。只是用来给程序去识别，确保数据的唯一性
        如果要识别机器是什么业务，属于什么机房什么的，这个应该另外搞个字段。
        这样做的目的在于尽量减小对资产id的维护。这个id没有业务上的意义，所以就能保证id一直不会变更。
        比如某个服务器业务可能会变更，也有可能从这个机房到别的机房，但是id可以不变。
        当一台新的主机被添加后，不应该直接就加入到资产管理中，应该是将信息收集起来发给服务器端，然后服务器端将数据暂存，
        然后由管理员审批，审批通过后才能加入到数据库中，然后返回记录给客户端。
        客户端下次再连接时，可以发送自己的SN号，通过SN号和服务器端的数据关联。
    2. 服务器表一对一的关联资产表,不能将一对一写在资产表里面
        因为资产表会被很多表关联,比如服务器表,网络设备表,这些表需要和资产表建立一对一的关联关系.
        所以,结果就是多个表一对一的关联到资产表,如果在资产表里面写OnetoOne的关系,那只能写一条,那
        么资产表就只能被一张表关联了.这就不符合业务需求了.所以,OneToOneField必需写在别的表里面.
        class Server(models.Model):
            asset=models.OneToOneField('Asset')
    3. 硬盘/内存等表关联
        没有在server服务器表里面写上硬盘的ManyToManyFeild关联,因为一块硬盘只能用于一台服务器,如果用多对多的关系,就可能
        出现多台服务器同时关联到一块硬盘的bug,这不符合实际应用需求.
        同时也不能在server服务器表里面写上ForeignKey外键关联或OneToOneField关联,因为一台服务器可能会有多块硬盘.不能只关联一条硬盘数据.
        所以,比较好的解决方案就是在硬盘表里面写上OneToOneField关联到server表的主机,这样就保证了每一块硬盘只会关联到一台
        主机,而多个硬盘可以同时OneToOneField到同一台主机,这样就实现了一台主机关联多块硬盘,而一块硬盘不会关联多台主机的需求.
    4. cpu与主机的关联
        class Cpu(CommonInfo):
        asset=models.OneToOneField('Asset')
        这里cpu关联到了Asset表,而不是关联到Server表,为什么?
        因为如果cpu关联到Server表之后,那么这个Cpu表就没办法再关联到路由器/交换机等其它设备表了.但是cpu表实际上应该是可以被
        服务器/路由器/交换机等各种设备关联的,毕竟这些所有设备上的cpu信息都可以记录在这一张表里面.没必要不同的设备弄不同cpu表,
        所以如果我们要实现cpu表关联多种设备表,那么可以采用中间表的方式来实现,即cpu关联Asset表,而Asset又关联到server/交换机/路由器
        等各种表,这样间接的实现了一张cpu表同时满足多张设备表的关联.
        Cpu-->Asset  Asset-->Server  Asset-->router
        一台主机其实可以有多个cpu,那么为什么是写的OneToOne呢? 那岂不是一台机器只有一个CPU了?
        其实这么设计的原因在于,每台机器的CPU型号其实都是一样的,CPU表里面的一条数据不是代表一个CPU,而是代表这台主机有一条这个型号的CPU记录,
        至于有几个,可以在对应的资产表里面再另外写上去.这样做的目的在于,每台主机就只用对应一条CPU的数据库记录了,而不需要一台主机对应多条重复
        的CPU记录,这样避免了出现重复的数据存放在CPU表里面.

django相关知识
    models中class Meta的用法
        参考:https://www.cnblogs.com/tongchengbin/p/7670927.html
        官方:https://docs.djangoproject.com/en/2.2/ref/models/options/
        verbose_name
            就是给你的模型类起一个更可读的名字,也就是给你的表名起个中文名字
        verbose_name_plural
            这个选项是指定模型的复数形式是什么,若未提供该选项, Django 会使用 verbose_name + "s".
        unique_together
            unique_together这个选项用于：当你需要通过两个字段保持唯一性时使用。
            这会在 Django admin 层和数据库层同时做出限制(也就是相关的 UNIQUE 语句会被包括在 CREATE TABLE 语句中)。
            比如：一个Person的FirstName和LastName两者的组合必须是唯一的，那么需要这样设置：
            unique_together = (("first_name", "last_name"),)
        ordering
            这个字段是告诉Django模型对象返回的记录结果集是按照哪个字段排序的。比如下面的代码：
            ordering=['order_date']
            # 按订单升序排列
            ordering=['-order_date']
            # 按订单降序排列，-表示降序
            ordering=['?order_date']
            # 随机排序，？表示随机
            ordering = ['-pub_date', 'author']
            # 对 pub_date 降序,然后对 author 升序
        db_table
            db_table是用于指定自定义数据库表名的。Django有一套默认的按照一定规则生成数据模型对应的数据库表名，
            如果你想使用自定义的表名，就通过这个属性指定，比如：
            db_table ='my_owner_table'
        abstract：
            如下段代码所示，将abstract设置为True后，CommonInfo无法作为一个普通的Django模型，
            而是作为一个抽象基类存在，作用是为其他的类提供一些公有的属性。
            如Student会拥有三个属性，即name，age，home_group。利于公用信息的分解，避免重复编码。
            from django.db import models
            class CommonInfo(models.Model):
                name = models.CharField(max_length=100)
                age = models.PositiveIntegerField()
                class Meta:
                    abstract = True

            class Student(CommonInfo):
                home_group = models.CharField(max_length=5)

    models中外键on_delete用法
        #models.py
        class Author(models.Model):
            author = models.CharField(max_length=250)
        class Books(models.Model):
            book = models.ForeignKey(Author,on_delete=models.CASCADE)
        CASCADE：删除作者信息一并删除作者名下的所有书的信息；
        PROTECT：删除作者的信息时，采取保护机制，抛出错误：即不删除Books的内容；
        SET_NULL：注意只有当当前字段设置null=True才有效，此情况会将ForeignKey字段设置为null
        SET_DEFAULT：设置为默认值；当前字段设置了default才有效，此情况会将ForeignKey 字段设置为default 值.
        SET( )：括号里可以是函数，设置为自己定义的东西；
        DO_NOTHING：字面的意思，啥也不干，你删除你的干我毛线关系

    models中null=True和blank=True的区别
        参考:https://docs.djangoproject.com/en/dev/ref/models/fields/#django.db.models.Field.blank
        之前也提起过,这里再次加深下理解
        null=True是数据库校验时用到的,代表允许值为Null.
        blank=True是django表单校验要用到的,代表允许存入数据库的值是空字符串.
        Django约定的允许为空即代表空字符串,如果在通过django插入该数据时,将该字段留空,那么,会插入一个空字符串到数据库中.而不是null.
        注意:空字符串 不等于 Null.
        所以:
            如果只写了null=True,那么通过django插入数据时还是不能插入空值,因为django校验是根据blank=True来判断的.
            如果只写了blank=True,那么在通过后台插入数据时,可以不填写该字段,这时插入到数据库中的是一个空字符串,注意不是Null.
            如果同时写了blank=True,null=True,那么通过django后台插入数据时,可以不填写该字段,这时候插入数据库的是Null,不再是空字符串.

        注意:
        1.如果你对这个字段添加了唯一性的约束unique=True,那么null=True就是必需的.因为如果是以空字符串存储的话,那么两个空字符串
        其实是相等的,那么就违反了唯一性约束条件了,但是两个Null是不违反唯一性约束的.所以,这个时候应该同时有blank=True,null=True.
        2.如果你的字段为日期类型/数字类型,那么这些类型的字段在某些数据库版本中,是不允许输入空字符串的,只允许Null,所以,这时候就
        必需写上null=True,让django存储Null而不是空字符串.

        应用场景:
            一般情况:输入数据允许为空:
                blank=True
            特殊情况:允许输入数据为空,但数据字段类型不允许为空字符串只能为Null的,比如数字类型/IP地址类型
                blank=True,null=True
            特殊情况:允许数据为空,但又不允许数据重复的
                blank=True,null=True,unique=True
            on_delete=models.SET_NULL时,null=True必需有
                idc = models.ForeignKey('IDC', on_delete=models.SET_NULL, verbose_name='IDC机房', blank=True,null=True)

    models中表关联关系解析
        OneToOneField,ForeignKey都需要定义on_delete参数
        一对多ForeignKey
            子表从母表中选出一条数据一一对应，但母表的这条数据还可以被其他子表数据选择.
            ForeignKey应该写在多方.

        一对一
            子表从母表中选出一条数据一一对应，母表中选出来一条就少一条，子表不可以再选择母表中已被选择的那条数据
            一对一一般用于对子表进行补充.

        应用场景
        一对一：一般用于某张表的补充，比如用户基本信息是一张表，但并非每一个用户都需要有登录的权限，不需要记录用户名和密码，此时，合理的做法就是新建一张记录登录信息的表，与用户信息进行一对一的关联，可以方便的从子表查询母表信息或反向查询

        外键：有很多的应用场景，比如每个员工归属于一个部门，那么就可以让员工表的部门字段与部门表进行一对多关联，可以查询到一个员工归属于哪个部门，也可反向查出某一部门有哪些员工

        多对多：如很多公司，一台服务器可能会有多种用途，归属于多个产品线当中，那么服务器与产品线之间就可以做成对多对，多对多在A表添加manytomany字段或者从B表添加，效果一致

    自定义用户表
        扩展修改原生的django认证系统
        https://docs.djangoproject.com/en/2.2/topics/auth/customizing/
        自定义的models需要放在一个app下面并且申明才能够使用.不能直接调用models文件,否则就报下面的错误了.
        RuntimeError: Model class stark.models.UserProfile doesn't declare an explicit app_label and isn't in an application in INSTALLED_APPS.

        在settings.py里面注册了Sansa,Wolf,在Sansa里面引用了Wolf的UserProfile,执行python manage.py makemigrations就报错了
        Sansa.Tag.creater: (fields.E307) The field Sansa.Tag.creater was declared with a lazy reference to 'Sansa.userprofile', but app 'Sansa' doesn't provide model 'userprofile'.

        settings.py里面注释掉Sansa后,写了这个AUTH_USER_MODEL = 'Wolf.UserProfile',再执行python manage.py migrate报错
        django.db.migrations.exceptions.InconsistentMigrationHistory: Migration admin.0001_initial is applied before its dependency Wolf.0001_initial on database 'default'.
        注释掉AUTH_USER_MODEL = 'Wolf.UserProfile'后,再执行migrate就通过了.
        网上查了下报这个错是因为我们数据库里面已经有了一些表了,所以冲突了.解决办法是将原来库里面建的表都删掉,再执行就好了.
        提示下面的错误是因为我们的Sansa的models.py里里面用外键引用UserProfile的时候,用了'UserProfile'的方式,去掉''就好
        错误的:creater = models.ForeignKey('UserProfile', on_delete=models.SET_NULL, null=True)
        正确的:creater = models.ForeignKey(UserProfile, on_delete=models.SET_NULL, null=True)
        ERRORS:
        Sansa.Asset.admin: (fields.E300) Field defines a relation with model 'UserProfile', which is either not installed, or is abstract.
        Sansa.Asset.admin: (fields.E307) The field Sansa.Asset.admin was declared with a lazy reference to 'Sansa.userprofile', but app 'Sansa' doesn't provide model 'userprofile'.
        Sansa.Tag.creater: (fields.E307) The field Sansa.Tag.creater was declared with a lazy reference to 'Sansa.userprofile', but app 'Sansa' doesn't provide model 'userprofile'.
        on_delete里面的models.SET_NULL必需配合null=True一起用,否则报错
        idc = models.ForeignKey('IDC', on_delete=models.SET_NULL, verbose_name='IDC机房', blank=True)
        Sansa.Asset.idc: (fields.E320) Field specifies on_delete=SET_NULL, but cannot be null.
                HINT: Set null=True argument on the field, or change the on_delete rule.

        IP地址格式的不能存储空字段,所以不能只写blank=True.要么去掉blank=True,要么blank=True,null=True同时存在
        Sansa.Asset.management_ip: (fields.E150) GenericIPAddressFields cannot have blank=True if null=False, as blank values are stored as nulls.


        1.建立一个app Wolf
        2.修改里面的models.py,将内容替换为认证系统里面的代码.
        在setting.py里面把Sansa,Wolf加入到INSTALLED_APPS里面
        2.在Sansa项目里面的models.py里面引用 from Wolf.models import UserProfile
        先把Sansa从setting.py里面注释掉
        把settings.py里面的AUTH_USER_MODEL = 'Wolf.UserProfile'先注释掉.
        然后先把用户系统建立成功
        python manage.py makemigrations
        python manage.py migrate
        上面的命令执行成功后会建立一个Wolf_userprofile表

        再到settings.py里面把AUTH_USER_MODEL = 'Wolf.UserProfile'打开
        python manage.py createsuperuser
        创建用户时,就提示输入Email地址和Name了,证明用的就是我们自己的认证系统了.
        创建一个sun@sun.com的用户,然后启动django登录.这时候整个用户系统都没有了.因为用了我们的新表
        再到Wolf里面把admin.py用官方代码写上,再进行修改.
        这之后就可以用自定义的后台创建修改用户了.



