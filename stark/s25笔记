
cmdb系统的设计

设计思路
    重点归纳:
        在数据表的一对一/多对多等的关联中,是A关联B,还是B关联A这个是有顺序的.不同的关联会实现不同的效果.
    1.用什么作为资产id?
        最好就用自增的数字来作为id，资产id不需要可识别，不需要有特殊意义。只是用来给程序去识别，确保数据的唯一性
        如果要识别机器是什么业务，属于什么机房什么的，这个应该另外搞个字段。
        这样做的目的在于尽量减小对资产id的维护。这个id没有业务上的意义，所以就能保证id一直不会变更。
        比如某个服务器业务可能会变更，也有可能从这个机房到别的机房，但是id可以不变。
        当一台新的主机被添加后，不应该直接就加入到资产管理中，应该是将信息收集起来发给服务器端，然后服务器端将数据暂存，
        然后由管理员审批，审批通过后才能加入到数据库中，然后返回记录给客户端。
        客户端下次再连接时，可以发送自己的SN号，通过SN号和服务器端的数据关联。
    2. 服务器表一对一的关联资产表,不能将一对一写在资产表里面
        因为资产表会被很多表关联,比如服务器表,网络设备表,这些表需要和资产表建立一对一的关联关系.
        所以,结果就是多个表一对一的关联到资产表,如果在资产表里面写OnetoOne的关系,那只能写一条,那
        么资产表就只能被一张表关联了.这就不符合业务需求了.所以,OneToOneField必需写在别的表里面.
        class Server(models.Model):
            asset=models.OneToOneField('Asset')
    3. 硬盘/内存等表关联
        没有在server服务器表里面写上硬盘的ManyToManyFeild关联,因为一块硬盘只能用于一台服务器,如果用多对多的关系,就可能
        出现多台服务器同时关联到一块硬盘的bug,这不符合实际应用需求.
        同时也不能在server服务器表里面写上ForeignKey外键关联或OneToOneField关联,因为一台服务器可能会有多块硬盘.不能只关联一条硬盘数据.
        所以,比较好的解决方案就是在硬盘表里面写上OneToOneField关联到server表的主机,这样就保证了每一块硬盘只会关联到一台
        主机,而多个硬盘可以同时OneToOneField到同一台主机,这样就实现了一台主机关联多块硬盘,而一块硬盘不会关联多台主机的需求.
    4. cpu与主机的关联
        class Cpu(CommonInfo):
        asset=models.OneToOneField('Asset')
        这里cpu关联到了Asset表,而不是关联到Server表,为什么?
        因为如果cpu关联到Server表之后,那么这个Cpu表就没办法再关联到路由器/交换机等其它设备表了.但是cpu表实际上应该是可以被
        服务器/路由器/交换机等各种设备关联的,毕竟这些所有设备上的cpu信息都可以记录在这一张表里面.没必要不同的设备弄不同cpu表,
        所以如果我们要实现cpu表关联多种设备表,那么可以采用中间表的方式来实现,即cpu关联Asset表,而Asset又关联到server/交换机/路由器
        等各种表,这样间接的实现了一张cpu表同时满足多张设备表的关联.
        Cpu-->Asset  Asset-->Server  Asset-->router
        一台主机其实可以有多个cpu,那么为什么是写的OneToOne呢? 那岂不是一台机器只有一个CPU了?
        其实这么设计的原因在于,每台机器的CPU型号其实都是一样的,CPU表里面的一条数据不是代表一个CPU,而是代表这台主机有一条这个型号的CPU记录,
        至于有几个,可以在对应的资产表里面再另外写上去.这样做的目的在于,每台主机就只用对应一条CPU的数据库记录了,而不需要一台主机对应多条重复
        的CPU记录,这样避免了出现重复的数据存放在CPU表里面.

django相关知识
    models中class Meta的用法
        参考:https://www.cnblogs.com/tongchengbin/p/7670927.html
        官方:https://docs.djangoproject.com/en/2.2/ref/models/options/
        verbose_name
            就是给你的模型类起一个更可读的名字,也就是给你的表名起个中文名字
        verbose_name_plural
            这个选项是指定模型的复数形式是什么,若未提供该选项, Django 会使用 verbose_name + "s".
        unique_together
            unique_together这个选项用于：当你需要通过两个字段保持唯一性时使用。
            这会在 Django admin 层和数据库层同时做出限制(也就是相关的 UNIQUE 语句会被包括在 CREATE TABLE 语句中)。
            比如：一个Person的FirstName和LastName两者的组合必须是唯一的，那么需要这样设置：
            unique_together = (("first_name", "last_name"),)
        ordering
            这个字段是告诉Django模型对象返回的记录结果集是按照哪个字段排序的。比如下面的代码：
            ordering=['order_date']
            # 按订单升序排列
            ordering=['-order_date']
            # 按订单降序排列，-表示降序
            ordering=['?order_date']
            # 随机排序，？表示随机
            ordering = ['-pub_date', 'author']
            # 对 pub_date 降序,然后对 author 升序
        db_table
            db_table是用于指定自定义数据库表名的。Django有一套默认的按照一定规则生成数据模型对应的数据库表名，
            如果你想使用自定义的表名，就通过这个属性指定，比如：
            db_table ='my_owner_table'
        abstract：
            如下段代码所示，将abstract设置为True后，CommonInfo无法作为一个普通的Django模型，
            而是作为一个抽象基类存在，作用是为其他的类提供一些公有的属性。
            如Student会拥有三个属性，即name，age，home_group。利于公用信息的分解，避免重复编码。
            from django.db import models
            class CommonInfo(models.Model):
                name = models.CharField(max_length=100)
                age = models.PositiveIntegerField()
                class Meta:
                    abstract = True

            class Student(CommonInfo):
                home_group = models.CharField(max_length=5)

    models中外键on_delete用法
        #models.py
        class Author(models.Model):
            author = models.CharField(max_length=250)
        class Books(models.Model):
            book = models.ForeignKey(Author,on_delete=models.CASCADE)
        CASCADE：删除作者信息一并删除作者名下的所有书的信息；
        PROTECT：删除作者的信息时，采取保护机制，抛出错误：即不删除Books的内容；
        SET_NULL：注意只有当当前字段设置null=True才有效，此情况会将ForeignKey字段设置为null
        SET_DEFAULT：设置为默认值；当前字段设置了default才有效，此情况会将ForeignKey 字段设置为default 值.
        SET( )：括号里可以是函数，设置为自己定义的东西；
        DO_NOTHING：字面的意思，啥也不干，你删除你的干我毛线关系

    models中null=True和blank=True的区别
        参考:https://docs.djangoproject.com/en/dev/ref/models/fields/#django.db.models.Field.blank
        之前也提起过,这里再次加深下理解
        null=True是数据库校验时用到的,代表允许值为Null.
        blank=True是django表单校验要用到的,代表允许存入数据库的值是空字符串.
        Django约定的允许为空即代表空字符串,如果在通过django插入该数据时,将该字段留空,那么,会插入一个空字符串到数据库中.而不是null.
        注意:空字符串 不等于 Null.
        所以:
            如果只写了null=True,那么通过django插入数据时还是不能插入空值,因为django校验是根据blank=True来判断的.
            如果只写了blank=True,那么在通过后台插入数据时,可以不填写该字段,这时插入到数据库中的是一个空字符串,注意不是Null.
            如果同时写了blank=True,null=True,那么通过django后台插入数据时,可以不填写该字段,这时候插入数据库的是Null,不再是空字符串.

        注意:
        1.如果你对这个字段添加了唯一性的约束unique=True,那么null=True就是必需的.因为如果是以空字符串存储的话,那么两个空字符串
        其实是相等的,那么就违反了唯一性约束条件了,但是两个Null是不违反唯一性约束的.所以,这个时候应该同时有blank=True,null=True.
        2.如果你的字段为日期类型/数字类型,那么这些类型的字段在某些数据库版本中,是不允许输入空字符串的,只允许Null,所以,这时候就
        必需写上null=True,让django存储Null而不是空字符串.

        应用场景:
            一般情况:输入数据允许为空:
                blank=True
            特殊情况:允许输入数据为空,但数据字段类型不允许为空字符串只能为Null的,比如数字类型/IP地址类型
                blank=True,null=True
            特殊情况:允许数据为空,但又不允许数据重复的
                blank=True,null=True,unique=True
            on_delete=models.SET_NULL时,null=True必需有
                idc = models.ForeignKey('IDC', on_delete=models.SET_NULL, verbose_name='IDC机房', blank=True,null=True)
        对于外键如果允许为空,就必需添加nulll=True,否则报错NOT NULL constraint failed: Sansa_bussinessunit.parent_unit_id
            parent_unit = models.ForeignKey('self', on_delete=models.CASCADE, related_name='parent_level', blank=True,null=True)

    models中表关联关系解析
        OneToOneField,ForeignKey都需要定义on_delete参数
        一对多ForeignKey
            子表从母表中选出一条数据一一对应，但母表的这条数据还可以被其他子表数据选择.
            ForeignKey应该写在多方.

        一对一
            子表从母表中选出一条数据一一对应，母表中选出来一条就少一条，子表不可以再选择母表中已被选择的那条数据
            一对一一般用于对子表进行补充.

        应用场景
        一对一：一般用于某张表的补充，比如用户基本信息是一张表，但并非每一个用户都需要有登录的权限，不需要记录用户名和密码，此时，合理的做法就是新建一张记录登录信息的表，与用户信息进行一对一的关联，可以方便的从子表查询母表信息或反向查询

        外键：有很多的应用场景，比如每个员工归属于一个部门，那么就可以让员工表的部门字段与部门表进行一对多关联，可以查询到一个员工归属于哪个部门，也可反向查出某一部门有哪些员工

        多对多：如很多公司，一台服务器可能会有多种用途，归属于多个产品线当中，那么服务器与产品线之间就可以做成对多对，多对多在A表添加manytomany字段或者从B表添加，效果一致

    自定义用户表
        扩展修改原生的django认证系统
        https://docs.djangoproject.com/en/2.2/topics/auth/customizing/
        自定义的models需要放在一个app下面并且申明才能够使用.不能直接调用models文件,否则就报下面的错误了.
        RuntimeError: Model class stark.models.UserProfile doesn't declare an explicit app_label and isn't in an application in INSTALLED_APPS.

        在settings.py里面注册了Sansa,Wolf,在Sansa里面引用了Wolf的UserProfile,执行python manage.py makemigrations就报错了
        Sansa.Tag.creater: (fields.E307) The field Sansa.Tag.creater was declared with a lazy reference to 'Sansa.userprofile', but app 'Sansa' doesn't provide model 'userprofile'.

        settings.py里面注释掉Sansa后,写了这个AUTH_USER_MODEL = 'Wolf.UserProfile',再执行python manage.py migrate报错
        django.db.migrations.exceptions.InconsistentMigrationHistory: Migration admin.0001_initial is applied before its dependency Wolf.0001_initial on database 'default'.
        注释掉AUTH_USER_MODEL = 'Wolf.UserProfile'后,再执行migrate就通过了.
        网上查了下报这个错是因为我们数据库里面已经有了一些表了,所以冲突了.解决办法是将原来库里面建的表都删掉,再执行就好了.

        提示下面的错误是因为我们的Sansa的models.py里里面用外键引用UserProfile的时候,用了'UserProfile'的方式,去掉''就好
        错误的:creater = models.ForeignKey('UserProfile', on_delete=models.SET_NULL, null=True)
        正确的:creater = models.ForeignKey(UserProfile, on_delete=models.SET_NULL, null=True)
        ERRORS:
        Sansa.Asset.admin: (fields.E300) Field defines a relation with model 'UserProfile', which is either not installed, or is abstract.
        Sansa.Asset.admin: (fields.E307) The field Sansa.Asset.admin was declared with a lazy reference to 'Sansa.userprofile', but app 'Sansa' doesn't provide model 'userprofile'.
        Sansa.Tag.creater: (fields.E307) The field Sansa.Tag.creater was declared with a lazy reference to 'Sansa.userprofile', but app 'Sansa' doesn't provide model 'userprofile'.

        on_delete里面的models.SET_NULL必需配合null=True一起用,否则报错
        idc = models.ForeignKey('IDC', on_delete=models.SET_NULL, verbose_name='IDC机房', blank=True)
        Sansa.Asset.idc: (fields.E320) Field specifies on_delete=SET_NULL, but cannot be null.
                HINT: Set null=True argument on the field, or change the on_delete rule.

        IP地址格式的不能存储空字段,所以不能只写blank=True.要么去掉blank=True,要么blank=True,null=True同时存在
        Sansa.Asset.management_ip: (fields.E150) GenericIPAddressFields cannot have blank=True if null=False, as blank values are stored as nulls.


        1.建立一个app Wolf
        2.修改里面的models.py,将内容替换为认证系统里面的代码.
        在setting.py里面把Sansa,Wolf加入到INSTALLED_APPS里面
        2.在Sansa项目里面的models.py里面引用 from Wolf.models import UserProfile
        先把Sansa从setting.py里面注释掉
        把settings.py里面的AUTH_USER_MODEL = 'Wolf.UserProfile'先注释掉.
        然后先把用户系统建立成功
        python manage.py makemigrations
        python manage.py migrate
        上面的命令执行成功后会建立一个Wolf_userprofile表

        再到settings.py里面把AUTH_USER_MODEL = 'Wolf.UserProfile'打开
        python manage.py createsuperuser
        创建用户时,就提示输入Email地址和Name了,证明用的就是我们自己的认证系统了.
        创建一个sun@sun.com的用户,然后启动django登录.这时候整个用户系统都没有了.因为用了我们的新表
        再到Wolf里面把admin.py用官方代码写上,再进行修改.
        这之后就可以用自定义的后台创建修改用户了.

    在admin后台将表注册进来,这样在admin后台就能够管理这些表了
    1. 在Sansa目录下编辑admin.py文件
        导入两个模块
        from django.contrib import admin
        from Sansa import models
        注册models中定义的Idc类
        admin.site.register(models.Idc)
        注册后,在django后台页面就可以看到这个表,可以新增修改表数据.
        注意:注册进来后,如果我们新增了数据,进入表之后我们看到的数据结果是定义的Models类return返回的结果.
        也就是说models类里面return返回什么,我们看到的就是什么.
        如果要正确的显示每一个自定义的字段,那么应该增加ModelAdmin功能
    2. 让插入的表数据显示在admin后台
        list_display代表指定需要显示的列.
    admin.py
        class NicAdmin(admin.ModelAdmin):
            list_display = ('name','macaddress','ipaddress',)
            search_fields = ['ipaddress']
         admin.site.register(models.Nic,NicAdmin)
        这样就能够正确的在admin后台显示我们想要的数据了.
    3. 在A表编辑B表的字段
        我们想在资产总表里面能够同时编辑cpu/内存等表的数据,因为它们之间都存在关联
        ServerInline中的设置只会对下面的AssetAdmin生效,在django的管理后台直接编辑该表是不受这个配置影响的.
        class ServerInline(admin.TabularInline):
            model = models.Server
            #定义被别的表引用编辑时,排除编辑的字段,这些字段不会出现在关联编辑中
            exclude = ('memo','hosted_on','os_distribution')
            #定义不可编辑字段
            readonly_fields = ['create_date','created_by']
        class CpuInline(admin.TabularInline):
            model = models.Cpu
            exclude = ('memo',)

        class AssetAdmin(admin.ModelAdmin):
            list_display = ('id','asset_type','sn','name','manufactory','management_ip','idc','bussiness_unit')
            inlines = [ServerInline,CpuInline,RamInline,NicInline]  #添加关联表的数据到asset的管理后台来
            search_fields = ['sn',]
            list_filter = ['idc','name','manufactory','asset_type']

写法:
        'os_distribution': distributor[1].strip() if len(distributor) > 1 else None,

windows处理模块(需要扩展学习)
    pypiwin32，在import win32com是需要安装这个模块。这个模块可以处理excel。具体详情未了解
    wmi 也是windows相关的处理模块,用于摘取硬件信息
    wmi微软官方说明:https://docs.microsoft.com/zh-cn/windows/win32/cimwin32prov/win32-diskdrive#examples

    import win32com,wmi
    wmi_obj=wmi.WMI()
    wmi_service_obj = win32com.client.Dispatch('WbemScripting.SWbemLocator')
    wmi_service_connector =wmi_service_obj.ConnectServer(".","root\cimv2")
    cpu_list=wmi_obj.Win32_Processor()
    cpu_list得到下面的列表
    [<_wmi_object: b'\\\\DESKTOP-NJDDDRC\\root\\cimv2:Win32_Processor.DeviceID="CPU0"'>]
    cpu_list[0] 取到列表里面的对象
    <_wmi_object: b'\\\\DESKTOP-NJDDDRC\\root\\cimv2:Win32_Processor.DeviceID="CPU0"'>
    cpu=cpu_list[0]
    dir(cpu)    查看对象里面有哪些方法
    注意:有些动态生成的方法或者从其它类里面调用的方法没法出现在dir里面,所以dir里面拿到的方法是不全的
    比如cpu.NumberOfcores,cpu.Name这些方法是有的,但是dir里面是没有的

    报错:
    import wmi  导入时报错    ModuleNotFoundError: No module named 'win32api'
    二、在使用import win32api时，报错:No module named win32api

     网上查到有下面解决办法：
    方法1：pip3 install pypiwin32 或 python -m pip install pypiwin32,
    我在我两台机器中的一台，用上面方法安装成功，解决了问题，但另一台机器未能解决。
    方法2：下载pywin32-221.win-amd64-py3.7.exe文件
    下载后，双击pywin32-221.win-amd64-py3.7.exe，会识别Python的安装路径，一路Next安装即可
     下载网址：https://sourceforge.net/projects/pywin32/files/pywin32/
     点击Build 221,下载和本机Python对应版本的pyWin32的版本
      import win32api,如下图，则表明正常了

转全栈开发day89
客户端开发
    1. 汇报新资产
        SN 是 唯一标识(不考虑虚拟机)  |  资产ID 资产的自增ID,让客户端通过自增ID来确认是谁
        if sn 不存在:
            放入待审批区
        else:
            判断是否信息有更新(我觉得可以将生成的数据md5,如果md5值不一样证明有数据变化,有变化则更新)
            取出旧数据,跟客户端数据进行对比

urllib3
    可以get,也可以post
    get
        req=urllib3.Request(url_with_args)
        req_data=urllib3.urlopen(req,timeout=settings.Params['request_timeout'])
        callback=req_data.read()
        print('server response-->',callback)
        return json.loads(callback)
    post
        post比get就多了以下两步,注意urlencode是用的urllib,不是urllib3
        先encode编码一下,然后传入data
        data_encode=urllib.urlencode(data)
        req=urllib3.Request(url=url,data=data_encode)

        下面的用法和get一样了
        res_data=urllib3.urlopen(req,timeout=settings.Params['request_timeout'])
        callback=res_data.read()
        callback=json.loads(callback)
        print("\033[31;1m[%s]:[%s]\033[0m response:\n%s" %(method,url,callback))
        return callback

hasaatr不仅可以判断对象是否有某方法,还可以判断是否有某属性.
    比如下面我们定义了  self.waiting_approval 这个属性,那就是给self添加了waiting_approval的属性
    self.waiting_approval = True    #如果在数据库里面查不到该数据,证明这是一台新机器,于是将等待批准状态设置为True
    然后就可以用hasattr来判断self是否有这个属性了.
    if hasattr(self,'waiting_approval'):

models里面可以支持get_or_create方法,查找or创建
        #get_or_create代表查找或者创建,也就是说当数据库里面存在这条数据时,我就只是查找数据而不插入,如果不存在则插入数据.
        #这样做避免了数据被重复创建
        asset_already_in_approval_zone=models.NewAssetApprovalZone.objects.get_or_create(sn=asset_sn,
    注意在定义models的时候,return返回的必需是字符串,否则会报如下错误
    TypeError at /admin/Sansa/newassetapprovalzone/1/change/
    __str__ returned non-string (type tuple)



判断字典是否存在key
        self.response={
            'error':[],
            'info':[],
            'warning':[],
        }
        if msg_type in self.response:
            print('存在key')

将post的数据里面加上一条数据{asset_data:obj.data}
    request.POST['asset_data'] = obj.data

进入django的shell
    python manage.py shell