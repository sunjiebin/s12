
一. 设计表结构
    1，贴子表

    2，评论表
        评论/回帖/点赞
    3，板块



class Article(models.Model):
    # 默认第一个字段就是verbose_name，如果不写，默认将用变量名称作为该名称,如title，那么django后台就会显示title
    title=models.CharField('文章标题',max_length=255)
    brief=models.CharField(null=True,blank=True,max_length=255,verbose_name='文章简介')

    models.CharField('文章标题',max_length=255) 和 models.CharField(verbose_name='文章标题',max_length=255) 是等价的
    这个注释不是存在数据库里面的，这个注释是给django后台用的，添加这个注释后，django后台就会显示这个名称，不添加默认就显示列名。
    注意: 在python2里面，如果写中文注释，前面要加个u。在python3里面不用写u，Python2写法如下
    title=models.CharField(u'文章标题',max_length=255)
    注意对于外键/多对多等，不能用('文章标题',)这种写法，因为这一类字段第一个参数必须是一个关联的表对象，所以不能写注释。

#引用django自带的用户
from django.contrib.auth.models import User

注意：
blank=True和null=True的区别：
blank=True表示用户可以不填写这个字段，用于用户输入校验。如果有唯一约束，两个blank为空的列会存储空字符串，会违反唯一性约束的。而两个null不会违反约束。
null=True表示允许数据库存储空字段，用于数据库的存储，不作用户校验
一般两个一起用，表示这个字段允许为空
head_img=models.ImageField(height_field=150,width_field=150,blank=True,null=True)


auto_now_add表示只在第一次创建的时候更新时间，auto_now表示每次修改数据都会更新时间。
    pub_date=models.DateTimeField(auto_now_add=True)
    last_modify=models.DateTimeField(auto_now=True)

创建django后台管理员用户
    python manage.py createsuperuser

修改settings.py文件，修改后台语言和时区
注意中文是zh-hans，写错了会导致无法启动。
    LANGUAGE_CODE = 'zh-hans'
    TIME_ZONE = 'Asia/Shanghai'

要用后台管理数据表，需要做两步
1.在admin.py中创建类
class ArticleAdmin(admin.ModelAdmin):
    '''list_display用于定义在后台显示的列'''
    list_display = ('title','category','author','pub_date','last_modify','status')

2.注册类
admin.site.register(models.Article,ArticleAdmin)

要在后台显示具体的文字，而不是对象信息就要写上这个函数。
__str__函数用于设置这个类的返回值，默认返回的是这个对象，定义这个函数后，返回的就是这里面写的值。
在python2里面，用__unicode__
        def __unicode__(self):
        return self.title
在python3里面，要用__str__,上面的unicode没用了。。
    '''定义str函数，这样在django后台的外键下拉框里面就会显示对应的name的值，而不是返回一个object的对象'''
    def __str__(self):
        return self.name


clean方法用于在后台django校验，当写了这个方法后，插入表数据时会先执行这个方法来校验。
下面的方法要求我们在帖子评论为空时，在admin后台会返回一个“评论不能为空”的错误。
    def clean(self):
         #这里用 self.comment == is None是错误的，当我们没有写评论时的值应该时''，而不是None。所以要用len来判断长度才对
        if self.comment_type==1 and len(self.comment)==0:
            raise ValidationError('评论不能为空')
django 认证
    导入认证模块
    from django.contrib.auth import login,logout,authenticate
    authenticate用于数据库验证，会根据post提交的username,password来去数据库查，
    如果匹配则返回user对象（如果我们在models的类里面定义了__str__，则返回str函数定义的值），不匹配则返回空
    这里的get('username'),get('password')就是django后台表auth_user里面的列名
        user = authenticate(username=request.POST.get('username'),password=request.POST.get('password'))
    login用于登录，根据前面验证成功的user对象以及request对象，来生成对应URL对应用户的session.实现登录。
        login(request,user)
    logout用于退出登录
        logout(request)
    is_authenticated() 判断是否认证成功
    在views视图验证
        def my_view(request):
            if not request.user.is_authenticated():
            return redirect('%s?next=%s' % (settings.LOGIN_URL, request.path))

    在前端html里面验证
        {% if request.user.is_authenticated %}
    在前端通过django自带的user表关联查询到userprofile表里面的name字段
    如果要通过user反查到userprofile表，首先在models里面定义userprofile表时，要添加OneToOneField字段，将user表与之一对一的关联。
    models.py
        user = models.OneToOneField(User,on_delete=models.CASCADE)
    这里一定要注意，页面里面通过user反向查找时，userprofile一定要小写，不是models里面定义的UserProfile。如果写models里面的类名称会查不出数据
        {{ request.user.userprofile.name }}

    登录校验装饰器，装饰一个函数或者类，这个函数就得在登录校验通过后才能访问，如果未登录，会跳转到登录页面，默认是django后台登录页面/accounts/login/
        from django.contrib.auth.decorators import login_required
        对index添加登录校验的装饰器，那么这个index.html页面就得先登录才能访问
        @login_required
        def index(request):
            #提取文章分类标签，过滤出set_as_top_menu为True的数据，并且依照position_index来排序
            category_list=models.Category.objects.filter(set_as_top_menu=True).order_by('position_index')       #倒序(-'position_index')
            return render(request,'bbs/index.html',{'category_list':category_list})
        可以修改settings.py,添加下面的参数，让认证不通过时跳转到我们指定的/login/页面，而不是默认的/accounts/login/。
        LOGIN_URL = '/login/'


前端页面设计
    在bootstrap上下载一个模板
    Bootstrap3中文文档-->起步-->实例精选-->bootstrap框架的基本用法 里面找打一个自己需要的模板  -->打开模板页面-->网页另存为。
    将里面的css文件全放到/statics/bootstrap-3.3.7-dist/css里面
    将里面的js文件放到/static/bootstrap-3.3.7-dist/js里面
    将首页放在templates目录下. 将首页命名为base.html，将里面的静态css/js路径替换为我们的路径
    在index.html中{% extends 'base.html' %}。 注意：就算base.html只是一个普通的页面，依然可以被extends引用。相当于index.html就是base.html

    注意我们在使用block时，位置不要搞错了。要么都在div里面，要么都在外面。不然样式会混乱
    {% block page-container %}
        <div class="jumbotron" deep="1">
            ....
        </div>
    {% endblock %}

    在前端页面通过外键反查数据
        comment表外键关联了article表。所以article表可以通过“关联表名_set"的方式反查关联表。
        select_related.count 反查与article该篇文章相关联的所有评论的总数（这里点赞也算在了里面）
        {{ article.comment_set.select_related.count }}
        html里面没法用filter去过滤输出,下面的写法在html里面是错误的！
        {{ article.comment_set.select_related.filter(comment_type=1).count }}       <--HTML模板并不支持这个写法

    views函数里面反查数据
        comment表里面设置了外键关联article表，那么我们可以通过article对象来反查comment里面的数据
        首先查询出id=article_id的文章对象artcile_obj，然后就可以利用这个对象来反查.
        注意filter（）得出来的是一个对象列表，而不是一个具体的对象。要得到对象，就得[0]
         article_obj=models.Article.objects.filter(id=article_id)[0]
         用get得到的就是单个的对象，但是用get时要注意返回的只能时一个值，要是查出来时多个值就会报错了。
          article_obj=models.Article.objects.get(id=article_id)
         comment_set中的comment代表comment表，_set代表对这个表反查。select_related()代表查询出于article_obj相关的comment表的数据
         article_obj.comment_set.select_related()

    filter过滤输出
        通过上面的方法可以查到所有与该篇文章相关联的评论总数，但是没法区分点赞和评论。可以用下面函数过滤的方法来实现。
        现定义一个filter函数
        @register.filter
        def filter_comment(article_obj):
            query_set=article_obj.comment_set.select_related()
            comments={
                'comment_count':query_set.filter(comment_type=1).count(),
                'thumb_count':query_set.filter(comment_type=2).count(),
            }
            return comments.get('comment_count')
        html模板中调用该filter函数，让函数去处理过滤信息，这样返回的就是评论的总数了（不包括点赞）
        {% load custom %}
        <span>{{ article|filter_comment }}</span>

    如何使用bootstrap里面的元素？
        参考：https://v3.bootcss.com/css/
        比如我们需要查看按钮的样式配置，可以直接参考上面的官档-->全局css样式-->右边的按钮，就看可以看到按钮的样式选择代码了
        比如如下就是一个绿色的成功按钮
        <button type="button" class="btn btn-success">（成功）Success</button>
        支持多行文本的表单控件。可根据需要改变 rows 属性。（全局css样式-->表单-->被支持的控件-->文本域)
        <textarea class="form-control" rows="3"></textarea>

    csrc_tocken
        前端通过这个函数会生成一个input标签。{% csrf_token %}
        <input type="hidden" name="csrfmiddlewaretoken" value="ZZfqgmDjdIhHQw6iONzGcuYu5tsHVRfPeuEpICUdFZDeoiBOncqbakD0EGmZUamY">
        可以通过jquery获得这个input标签里面的value
        function getcsrf(){
            var csrftoken = $('input[name="csrfmiddlewaretoken"]').val();
            return csrftoken;
        }
        执行getcsrf()将返回csrftoken的值。
        在post中，转递这个csrf键值对给服务器即可通过验证。
        注意name名称csrfmiddlewaretoken不能错。
         csrfmiddlewaretoken:getcsrf(),

    跳转带上参数路径
        {{ request.path_info }} 获取当前页面的url路径
        后端函数可以通过get('next')获取到前端传过来的next=/xxx。next=/aaa.html在request.GET里面会成为一个字典{'next':'/aaa.html'}
     html:
        <a class="btn-link" href="{% url 'login' %}?next={{ request.path_info }}">登录</a>后再评论!</h4>
     views:
        backurl=request.GET.get('next')
        return HttpResponseRedirect(backurl or'/bbs')       # or用于当backurl为空时，则自动跳转到用/bbs

    前端登录校验
        request.user.is_authenticated 是django自带的用户校验工具，用于校验用户是否已经登录
        {% if request.user.is_authenticated %}
            <textarea class="form-control" rows="4"></textarea>
            <button class="btn btn-sm btn-primary pull-right" style="margin-top:10px;">评论</button>
        {% else %}
            <div class="jumbotron" style="text-align: center">
                <h4><a class="btn-link" href="{% url 'login' %}?next={{ request.path_info }}">登录</a>后再评论!</h4>
            </div>
        {% endif %}

    利用jquery的post提交数据
        提交数据可以用form/ajax/iframe等，还可以用$.post()的写法，比ajax写法更简洁
        $.post(
            "{% url 'post_comment' %}",
            {
                comment_type: 1,
                article_id: '{{ article_obj.id }}',
                parent_comment_id: null,
                comment: comment_text.trim(),
                csrfmiddlewaretoken: getcsrf(),
            },
            function (callback) {
                console.log(callback);
            }
        )

    url灵活写法
        在html不将url写死，这样以后在别的地方移植，或者我们需要更改url路径时，就不用再修改静态页面里面的url了。这么写通用性更高，更灵活，便于移植。
        首先在urls.py里面写path时，加上name参数，如
            path('login/',views.acc_login,name='login'),
        然后在html页面里面通过url来直接调用， 其中的'login'就是对应上面urls.py里面的name的值。{% url 'login' %}  -->等价于 login/
            {% url 'login' %}
            <h4><a class="btn-link" href="{% url 'login' %}?next={{ request.path_info }}">登录</a>后再评论!</h4>
        article_obj.id=1时，下面的url等价于/get_comments/1
            re_path('get_comments/(\d+)',views.get_comments,name='get_comments'),
            {% url 'get_comments' article_obj.id %}

        static静态路径也可以这么写
            在html中：
            {% load  custom static %}
            {% truncate_url article_obj.head_img.url as imgpath %}
            <img class="article-detail-head-img" src="{% static imgpath %}"/>


django静态页面STATIC_URL
    定义URL映射
    STATIC_URL = '/static/'

    STATIC_ROOT 是在部署的时候才发挥作用,执行 python managy.py collectstatic ，会在工程文件下生成(STATIC_ROOT )文件夹，把各个app下的静态文件收集到这个目录下。
   利于前后端分离，比如将静态资源交给Nginx。这个参数默认没有
    STATIC_ROOT = os.path.join(BASE_DIR, 'collect_static')

    STATICFILES_DIRS 定义静态文件的目录，可以同时定义多个静态文件夹
    静态文件的一般安放位置有两种:
    (1).一种就是在每个app里面新建一个static文件夹，将静态文件放到里面，在加载静态文件时，比如要在模板中用到静态文件，django会自动在每个app里面搜索static文件夹(所以，不要把文件夹的名字写错， 否则django就找不到你的文件夹)。
    (2).另一种,就是在所有的app文件外面，建立一个公共的文件夹,，也就是我们的STATICFILES_DIRS。因为有些静态文件不是某个app独有的,那么就可以把它放到一个公共文件夹里面，方便管理(注意，建立一个公共的静态文件的文件夹只是一种易于管理的做法，但是不是必须的，app是可以跨app应用静态文件的，因为最后所有的静态文件都会在STATIC_ROOT里面存在) 
    那现在的问题是如何让django知道你把一些静态文件放到app以外的公共文件夹中呢，那就需要配置STATICFILES_DIRS了

    在static标签中引用文件时有两个查找路径：1、app下的static。2、工程下的commen_static（STATICFILES_DIRS） 。
    STATICFILES_DIRS告诉django,首先到STATICFILES_DIRS里面寻找静态文件,其次再到各个app的static文件夹里面找(注意，django查找静态文件是惰性查找，查找到第一个，就停止查找了)

    可以同时定义多个目录，如果有同名文件，依照惰性查找规则，找到第一个就不管后面是否还有同名的文件了
    STATICFILES_DIRS=(
        os.path.join(BASE_DIR,'static'),
        os.path.join(BASE_DIR,'uploads'),
    )

    可以在html里面用变量替代静态页路径，这样便于我们页面的移植，其他人用我们的代码就不用修改静态url路径
    首先在html最上面load载入static模块
    {% load static %}
    动态的获取我们的图片地址，这里用了truncate_url来处理了图片的url。 as imgpath 代表将处理的结果赋值给变量imgpath
    {% truncate_url article.head_img.url as imgpath %}
    static是内置静态url函数，会返回setting.xml里面STATIC_URL定义的值。 imgpath是我们上面定义的变量，也就是函数处理过的图片路径。两者相加得到最终路径
    <img src="{% static imgpath %}"/>
    比如
    imgpath='img/aa.jpg'
    STATIC_URL = '/static/'
    那么
    <img src="{% static imgpath %}"/>  --> 将得到 /static/img/aa.jpg


views
    定义返回url，自动跳回原来的url
        当url=http://127.0.0.1:8000/login/?next=/bbs/detail/1
        request.GET.get()将获得一个queryset的值，结果{'next':'/bbs/detail/1'},所以 request.GET.get('next') = ‘/bbs/detail/1’

        HttpResponseRedirect(backurl or'/bbs')  返回值可以写or，当backurl为空时，就执行后面的/bbs。
        所以，当我们直接访问登录url时，url=http://127.0.0.1:8000/login/, 这时候GET后面为空，就会跳转到http://127.0.0.1:8000/bbs/
        当我们从帖子页面过来时，url=http://127.0.0.1:8000/login/?next=/bbs/detail/1, 就会跳到http://127.0.0.1:8000/bbs/detail/1
            backurl=request.GET.get('next')
            return HttpResponseRedirect(backurl or'/bbs')

    注意：当我返回的是一个html时，是不需要json.dumps的。多此一举。如果用了json.dumps传给前端，那么前端必须要用JSON.parse()来解析出来。
    否则，当我们传递给前端的html中有中文时，前端中文显示就会变成 \u5f53\u7136OK\u4e86\uff01
    错误示例：
    views函数
             return HttpResponse(json.dumps(comment_tree))
        传递值在views里面print显示为 <span style='margin-left:10px'>建立就立刻</span>

    js接收
                function (callback) {
                    console.log(callback);

                    {#callback = decodeURIComponent(callback);#}
                    $('.comment-list').html(callback);
                }
         console.log和前端打印出来的结果为：<span style='margin-left:10px'>\u5efa\u7acb\u5c31\u7acb\u523b</span>

    正确示例
        views
            return HttpResponse(json.dumps(comment_tree))
        js
            $('.comment-list').html(JSON.parse(callback));
    或者
        views
            return HttpResponse(comment_tree)
        js
            $('.comment-list').html(callback));

    此时前端和后台的中文都会正确显示: <span style='margin-left:10px'>建立就立刻</span>

    当我们get数据时，如果为None会报错，可以写的时候后面加上or None就行了。如果有数据则得到数据，没有就时None.
    parent_comment_id=request.POST.get('parent_comment_id') or None,

    在发布评论后，一般最后发的评论应该放在最前面，所以需要倒序排列
    order_by()用于排序。列名如果有-号则代表倒序，没有就是正序
    以下为以id倒序排列
        comment_related=article_obj.comment_set.select_related().order_by('-id')

    回复评论绑定事件：
        给回复评论绑定事件，注意这个事件必须写在get_Comment的function里面。如果不写这里会出现事件无法绑定的情况，
        导致按钮点击没有反应，无法触发点击事件。
        这是因为js的函数时异步执行的，如果写在get_comment()函数外面，那么当get_Comment()都还没有执行完时，这个click
        函数就已经执行了，而此时评论都还没有获取到，自然就无法对这些评论绑定事件了。
        所以，必须先等评论加载完后，再绑定事件。那么为了保证执行顺序，就需要把这个click事件写道get_Comment()的function函数里面，
        确保评论已经加载完成后再执行这个绑定事件。
            function get_Comment() {
            $.get("{% url 'get_comments' article_obj.id %}",
                function (callback) {
                    {#console.log(callback);#}
                    $('.comment-list').html(callback);
                    // click事件必须写在这个里面
                    $('.click-comment').click(function () {
                        var id = $(this).attr('comment-id');
                        console.log(id);
                    })
                }
            )
        }